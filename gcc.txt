查看文件格式：
	file fileName
gcc工作流程：
	预处理（参数：-E，预处理工具：cpp）
		*去除注释
		*头文件展开
		*宏替换
		xxx.c->xxx.i
	编译（参数：-s，编译工具gcc）
		得到汇编文件
		xxx.i->xxx.s
	汇编（参数：-c，汇编工具：as)
		得到二进制文件
		xxx.s->xxx.o
	链接(链接工具：ld）
		xxx.o->xxx(可执行文件,不指定文件名默认为a.out）
gcc常用参数：
	-L：指定静态库的路径
	-l：指定库的名字，需要去掉前缀和后缀
	-I：编译的时候指定头文件，后面跟路径名
	-o：编译的时候指定编译完成后的链接名
	-c:生成一个后缀为.o的二进制文件
	-g:gdb调试的时候需要用到
	-D:在编译的时候指定一个宏（linux基础编程，gcc的参数里面有讲,）
	-Wall:在编译的时候输出警告信息
	-On:优化代码，n化级别1,2,3，3的优化级别最高
库的介绍：
	1、库是什么：
		*库是二进制文件
		*二进制文件相当于加密，用反汇编工具对c和C++进行反汇编得到的正确率是相当的低的
	2、库制作出来以后如何给用户使用：
		*头文件（函数的声明，给用户看的）
		*库文件（函数的实现，二进制文件，相当于加密过的，不给用户看的)
	3、静态库的制作：
		命名规则：(例如：libtest.a）
			*头缀：lib
			*库名：xxx
			*后缀：.a
		制作步骤：
			*将.c .cpp加-c参数生成后缀为.o的二进制文件
			*将.o文件打包成为静态库
				ar rcs 静态库名 .o二进制文件
				ar rcs libtest.a a.o b.o
				ar --archive
	`		*可以使用nm查看静态库里面的.o文件和函数
		静态库的使用：
			gcc -I./include -L./lib -ltest -o app
			-I指定头文件路径
			-L指定库文件（.a文件）路径
			-l指定库的名字（去掉lib和.a）			
	4、动态库的制作和使用
		命名规则：libxxx.so
		制作步骤：
			将源文件汇编成.o文件：gcc -c a.c b.c -fpic(fPIC)
			将.o文件打包：gcc -shared -o libxxx.so a.o b.o(二进制文件和动态库名顺序可兑换）
		动态库的使用：
			gcc -I./include -L./lib -ltest -o app
		动态库无法使用
			[注：动态链接库和静态链接库的加载原理不一样，当执行了上述步骤后，依然会出现动态链接库的路径找不到的提示。*当系统加载可执行代码时，能知道依赖库的名称，但是也需要知道依赖库的路径，此时就需要系统动态载入器		*对于elf的可执行文件（gcc执行生成的可执行文件就是elf格式的可执行文件),ld-linux.so*先后搜索elf文件的DT_RPATH段、环境变量LD_LIBRARY_PATH、/etc/ls.so.cache文件列表、/lib或/usr/lib目录找到库文件后将其加载入内存。如何让系统找到共享库：1、将共享库文件拷贝到/lib或/usr/lib中	2、设置LD_LIBRARY_PATH变量等于路径]
			临时设置：
				在终端export LD_LIBRARY_PATH=动态链接库路径
				(echo $LD_LIBRARY_PATH可以显示变量LD_LIBRARY_PATH的值，在设置动态链接库的路径的时候会覆盖原有的LD_LIBRARY_PATH的值，所以最好写为export LD_LIBRARY_PATH=动态链接库路径:$LD_LIBRARY_PATH)
			永久设置：
				用户级别(只对当前用户生效)：～/.bashrc 文件尾部添加export LD_LIBRARY_PATH=动态链接库路绝对路径:$LD_LIBRARY_PATH
				配置完成之后需要重启终端或者执行source(source可以用.代替） ～/.bashrc(每次打开终端的时候就会加载.bashrc然后执行里面命令进行初始化，所以完成配置后需要重新加载.bashrc文件）
				系统级别：
					1、写改etc/profile	
					2、在/etc/ld.so.conf文件里面添加动态库的绝对路径后执行sudo ldconfig -v
				扩展：可以使用函数调用的方式调用函数库dlopen、dlclose、dlsym

动态库静态库工作原理及优缺点：
	静态库：
		优点：
			1、在编译时被引用的静态库部分被打包到应用程序中，加载速度很快
			2、发布程序时无需提供静态库，移植很方便
		缺点：
			1、浪费系统内存（比如两个应用调用了相同的静态库，就会在内存中载入相同的两个静态库）
			2、应用更新，发布时很麻烦，用户体验不好
	动态库：（应用程序编译好后，动态链接库不会打包在应用中。只有引用到动态链接库中的内容时，才会吧动态链接库加载到内存中）

		优点：
			1、能实现进程之间的资源共享
			2、程序更新，升级简单
			3、程序员可以控制合适加载动态库
		缺点：
			1、加载速度比静态库慢
			2、发布程序要依赖提供的动态库
